<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Daily Horse Racing Picks</title>
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:24px;max-width:980px}
  header{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:16px}
  select,input,button{font:inherit;padding:6px 8px}
  .race{border:1px solid #ddd;border-radius:8px;padding:12px;margin:12px 0}
  .race h2{margin:0 0 8px 0}
  .pick{padding:6px 8px;border-left:4px solid #ccc;margin:6px 0}
  .high{border-color:#4caf50}.medium{border-color:#ffa000}
  .meta{color:#666;font-size:12px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .stats {border:1px solid #ddd;border-radius:8px;padding:10px 12px;margin:12px 0;background:#fafafa;display:flex;gap:16px;flex-wrap:wrap}
  .stats b {font-weight:600}
  .stats .pill{padding:2px 8px;border-radius:999px;border:1px solid #ccc;background:#fff}
  @media(max-width:720px){.grid{grid-template-columns:1fr}}
</style>

<header>
  <h1 style="margin-right:auto;">Daily Horse Racing Picks</h1>
  <label>Month:
    <select id="month"></select>
  </label>
  <label>Day:
    <select id="day"></select>
  </label>
  <button id="load">Load</button>
  <button id="latest">Latest</button>
  <label>Min odds:
  <input id="minOdds" type="number" step="0.01" min="1" placeholder="e.g. 1.5" style="width:7ch">
  </label>
  <label>Max odds:
    <input id="maxOdds" type="number" step="0.01" min="1" placeholder="e.g. 6.0" style="width:7ch">
  </label>
  <button id="apply">Apply</button>
</header>

<p class="meta" id="stamp"></p>
<div id="root">Loading…</div>

<script>
const monthSel = document.getElementById('month');
const daySel = document.getElementById('day');
const stamp = document.getElementById('stamp');
const root = document.getElementById('root');

async function fetchJSON(url){
  const res = await fetch(url, {cache:'no-store'});
  if(!res.ok) throw new Error(`GET ${url} -> ${res.status}`);
  return res.json();
}
// === stats helpers ===
function toDec(x){
  if (x == null) return null;
  if (typeof x === 'number' && isFinite(x)) return x;
  if (typeof x === 'string'){
    const s = x.trim();

    // plain decimal: "3.85"
    if (/^\d+(\.\d+)?$/.test(s)) return parseFloat(s);

    // fractional like "9/4" -> 3.25
    const m = s.match(/^(\d+)\s*\/\s*(\d+)$/);
    if (m) { const a=+m[1], b=+m[2]; if (b) return a/b + 1; }

    // pull first number from a note like "EXC 3.85" or "SBK 5/2"
    const num = s.match(/(\d+(?:\.\d+)?)(?:\s*\/\s*(\d+))?/);
    if (num){
      if (num[2]) { const a=+num[1], b=+num[2]; if (b) return a/b + 1; }
      return parseFloat(num[1]);
    }
  }
  return null;
}

function pickDecimalOdds(p){
  return (
    toDec(p.exc_dec) ??
    toDec(p.exchange) ??
    toDec(p.odds) ??
    toDec(p.odds_note) ??
    null
  );
}

function normName(s){ return (s||'').toLowerCase().replace(/\s+/g,' ').trim(); }

function summarize(dayData, resultsJson){
  const resByKey = new Map(resultsJson.results.map(r => [`${r.course.trim()}||${r.time.trim()}`, r]));
  let hits=0, misses=0, racesWithResult=0;

  let bets=0, wins=0, pnl=0, staked=0;

  for (const r of (dayData.races||[])){
    const key = `${(r.course||'').trim()}||${(r.time||'').trim()}`;
    const res = resByKey.get(key);
    if (res && res.winner) {
      racesWithResult++;
      const wName = normName(res.winner.name);
      const short = r.shortlist || [];

      // race hit/miss
      const raceHit = short.some(p => normName(p.name) === wName);
      if (raceHit) hits++; else misses++;

      // per-pick betting P/L (1€ each) if odds exist
      for (const p of short){
        const dec = pickDecimalOdds(p);
        if (dec){
          bets++;
          staked += 1;
          const isWin = normName(p.name) === wName;
          if (isWin){
            wins++;
            pnl += (dec - 1); // net profit on 1€ stake
          } else {
            pnl -= 1;
          }
        }
      }
    }
  }

  const roi = staked ? (pnl / staked) : 0;
  return { hits, misses, racesWithResult, bets, wins, staked, pnl, roi };
}

function renderStatsHeader(stats){
  // remove old
  document.getElementById('statsbar')?.remove();

  const d = document.createElement('div');
  d.id = 'statsbar';
  d.className = 'stats';
  d.innerHTML = `
    <div><b>Results coverage:</b> ${stats.racesWithResult}</div>
    <div class="pill"><b>Hits:</b> ${stats.hits}</div>
    <div class="pill"><b>Misses:</b> ${stats.misses}</div>
    <div class="pill"><b>Bets:</b> ${stats.bets}</div>
    <div class="pill"><b>Wins:</b> ${stats.wins}</div>
    <div class="pill"><b>P/L:</b> €${stats.pnl.toFixed(2)}</div>
    <div class="pill"><b>ROI:</b> ${(stats.roi*100).toFixed(1)}%</div>
  `;
  // stick it under the header controls, above #stamp
  const header = document.querySelector('header');
  header.insertAdjacentElement('afterend', d);
}
function render(data){
  stamp.textContent = `Model: ${data.model || 'n/a'} • Generated: ${new Date(data.generated_at || Date.now()).toLocaleString()}`;
  root.innerHTML = '';
  for (const r of (data.races || [])) {
    const div = document.createElement('div'); div.className = 'race';
    div.innerHTML = `<h2>${r.course} — ${r.time}</h2>
      <div class="meta"><a href="${r.url}" target="_blank" rel="noopener">Racecard</a></div>`;
    if (!r.shortlist?.length) {
      div.innerHTML += `<p>No shortlisted picks.</p>`;
    } else {
      for (const p of r.shortlist) {
        const conf = (p.confidence||'').toLowerCase();
        div.innerHTML += `<div class="pick ${conf.includes('high')?'high':conf.includes('medium')?'medium':''}">
          <strong>${p.name}</strong> — ${p.rationale || ''}<br/>
          <span class="meta">
            ${p.jockey?`J: ${p.jockey} • `:''}${p.trainer?`T: ${p.trainer} • `:''}${p.form?`F: ${p.form} • `:''}${p.odds_note||''}
          </span>
        </div>`;
      }
    }
    root.appendChild(div);
  }
}
async function tryFetchResultsFor(dateStr) {
  const [Y,M] = dateStr.split('-');
  const url = `./results/${Y}/${M}/${dateStr}.json`;
  const res = await fetch(url, {cache:'no-store'});
  if (!res.ok) return null;
  return res.json();
}

// After you load a day file, call:
async function renderWithResults(dayData) {
  currentDayData = dayData;
  render(dayData);

  // derive YYYY-MM-DD
  const d = (dayData.date)
    || (dayData.generated_at ? new Date(dayData.generated_at).toISOString().slice(0,10) : null);

  currentResults = d ? await tryFetchResultsFor(d) : null;

  // annotate DOM with results (unchanged from your code)
  if (currentResults) {
    const byKey = new Map(currentResults.results.map(r => [`${r.course}||${r.time}`, r]));
    for (const el of document.querySelectorAll('.race')) {
      const h2 = el.querySelector('h2');
      if (!h2) continue;
      const [course, time] = h2.textContent.split(' — ');
      const k = `${course}||${time}`;
      const r = byKey.get(k);
      if (!r) continue;
      const badge = document.createElement('div');
      badge.className = 'meta';
      if (r.winner) {
        badge.textContent = `Result: ${r.winner.name}${r.winner.sp ? ` (SP ${r.winner.sp})` : ''} • ${r.hit ? '✅ HIT' : '❌ MISS'}`;
      } else {
        badge.textContent = 'Result: not available';
      }
      el.insertBefore(badge, el.querySelector('.meta + *'));
    }
  }

  // compute header stats with current filter
  applyFilterAndRenderHeader();
}

function getFilterBounds() {
  const minStr = minOddsEl.value.trim();
  const maxStr = maxOddsEl.value.trim();
  const minDec = minStr ? parseFloat(minStr) : null;
  const maxDec = maxStr ? parseFloat(maxStr) : null;
  return {
    min: Number.isFinite(minDec) && minDec >= 1 ? minDec : null,
    max: Number.isFinite(maxDec) && maxDec >= 1 ? maxDec : null
  };
}

function applyFilterAndRenderHeader() {
  const {min, max} = getFilterBounds();
  const stats = computeHeaderStats(currentDayData, currentResults || {results: []}, min, max);
  renderHeader(stats, min, max);
}

async function loadLatest(){
  const data = await fetchJSON('./latest.json');
  await renderWithResults(data);
}

async function loadDay(path){
  const data = await fetchJSON('./' + path);
  await renderWithResults(data);
}

function populate(index){
  // months sorted descending
  const months = Object.keys(index.months || {}).sort().reverse();
  monthSel.innerHTML = months.map(m => `<option value="${m}">${m}</option>`).join('');
  if (months.length) {
    const first = months[0];
    daySel.innerHTML = index.months[first].slice().reverse()
      .map(d => `<option value="${d.path}">${d.date}</option>`).join('');
  }
}

document.getElementById('apply').addEventListener('click', applyFilterAndRenderHeader);

// Recompute when hitting Enter in either input
[minOddsEl, maxOddsEl].forEach(el => {
  el.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') applyFilterAndRenderHeader();
  });
});

monthSel.addEventListener('change', async () => {
  const idx = await fetchJSON('./picks/index.json');
  const key = monthSel.value;
  const days = (idx.months && idx.months[key]) ? idx.months[key].slice().reverse() : [];
  daySel.innerHTML = days.map(d => `<option value="${d.path}">${d.date}</option>`).join('');
});

document.getElementById('load').addEventListener('click', async () => {
  const p = daySel.value;
  if (p) loadDay(p);
});

document.getElementById('latest').addEventListener('click', loadLatest);

(async () => {
  try {
    const idx = await fetchJSON('./picks/index.json');
    populate(idx);
    await loadLatest();
  } catch (e) {
    console.error(e);
    root.textContent = 'No data yet.';
  }
})();
// ---- FILTER STATE ----
let currentDayData = null;
let currentResults = null;
const minOddsEl = document.getElementById('minOdds');
const maxOddsEl = document.getElementById('maxOdds');

// Robust odds parser: decimal like "2.48", or fractional like "5/2"
function parseDecimalFromText(s) {
  if (!s) return null;
  s = String(s);

  // Try explicit "exchange" or "decimal" first (common in your JSON)
  const ex = s.match(/(?:exchange|decimal)\s*[:=]?\s*([0-9]+(?:\.[0-9]+)?)/i);
  if (ex) {
    const v = parseFloat(ex[1]);
    if (v >= 1) return v;
  }

  // Any standalone decimal >= 1.0
  const dec = s.match(/(^|\s)([1-9]\d*(?:\.\d+)?)(?=\s|$|,)/);
  if (dec) {
    const v = parseFloat(dec[2]);
    if (v >= 1) return v;
  }

  // Fraction like "5/2" → 3.5
  const frac = s.match(/([0-9]+)\s*\/\s*([0-9]+)/);
  if (frac) {
    const a = parseFloat(frac[1]), b = parseFloat(frac[2] || '1');
    if (b > 0) return (a / b) + 1;
  }

  return null;
}

// Pull a decimal from a pick object (checks multiple fields)
function pickDecimalOdds(pick) {
  // direct numeric fields first
  const direct = [pick.exchange, pick?.odds?.exchange, pick?.odds?.decimal]
    .map(v => Number(v))
    .find(v => Number.isFinite(v) && v >= 1);
  if (direct) return direct;

  // string fields where "exchange" is mentioned next to a number
  const candidates = [];
  if (typeof pick.odds_note === 'string') candidates.push(pick.odds_note);
  if (typeof pick.odds === 'string') candidates.push(pick.odds);
  if (typeof pick.rationale === 'string') candidates.push(pick.rationale);

  for (const s of candidates) {
    if (!s) continue;
    // Try “exchange 2.48” or “2.48 (exchange)”
    let m = s.match(/exchange[^0-9]*([1-9]\d*(?:\.\d+)?)/i);
    if (!m) m = s.match(/([1-9]\d*(?:\.\d+)?)[^0-9]*\(\s*exchange\s*\)/i);
    if (m) {
      const v = parseFloat(m[1]);
      if (v >= 1) return v;
    }
  }

  // If we cannot positively identify an exchange price, do not count this pick.
  return null;
}

function normName(s){ return (s||'').toLowerCase().replace(/\s+/g,' ').trim(); }

function withinRange(dec, min, max) {
  if (min != null && dec < min) return false;
  if (max != null && dec > max) return false;
  return true;
}

// Compute header stats with optional odds range
function computeHeaderStats(dayData, resultsJson, minDec, maxDec) {
  if (!dayData || !resultsJson) return {hits:0, misses:0, staked:0, pnl:0};
  const resByKey = new Map((resultsJson.results || []).map(r => [`${(r.course||'').trim()}||${(r.time||'').trim()}`, r]));
  let hits = 0, misses = 0, staked = 0, pnl = 0;

  for (const race of (dayData.races || [])) {
    const key = `${(race.course||'').trim()}||${(race.time||'').trim()}`;
    const res = resByKey.get(key);
    if (!res || !res.winner) continue; // skip no-result races

    const wName = normName(res.winner.name);
    const picks = (race.shortlist || []);

    // Apply odds range filter to picks
    const filtered = picks.filter(p => {
      const dec = pickDecimalOdds(p);
      return dec && withinRange(dec, minDec, maxDec);
    });

    if (!filtered.length) continue; // nothing to count for this race

    const raceHit = filtered.some(p => normName(p.name) === wName);
    if (raceHit) hits++; else misses++;

    for (const p of filtered) {
      const dec = pickDecimalOdds(p);
      if (!dec) continue;
      staked += 1;
      pnl += (normName(p.name) === wName) ? (dec - 1) : -1;
    }
  }
  return {hits, misses, staked, pnl};
}

// Render header line
function renderHeader(stats, minDec, maxDec) {
  const filt =
    (minDec != null || maxDec != null)
    ? ` • Filter: ${minDec!=null?`≥${minDec}`:''}${(minDec!=null && maxDec!=null)?' & ':''}${maxDec!=null?`≤${maxDec}`:''}`
    : '';
  const plStr = (stats.pnl >= 0 ? '+' : '') + stats.pnl.toFixed(2);
  const stakedStr = stats.staked.toString();
  const rangeNote = filt || '';
  const extra = rangeNote ? ` ${rangeNote}` : '';
  // update the existing #stamp line by appending stats
  const base = stamp.textContent.split(' • P/L')[0]; // crude cut to avoid duplication
  stamp.textContent = `${base} • Hits/Misses: ${stats.hits}/${stats.misses} • P/L (€1 stakes): ${plStr} over ${stakedStr} picks${extra}`;
}
</script>
</html>
