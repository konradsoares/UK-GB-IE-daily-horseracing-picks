<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Daily Horse Racing Picks</title>
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:24px;max-width:980px}
  header{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:16px}
  select,input,button{font:inherit;padding:6px 8px}
  .race{border:1px solid #ddd;border-radius:8px;padding:12px;margin:12px 0}
  .race h2{margin:0 0 8px 0}
  .pick{padding:6px 8px;border-left:4px solid #ccc;margin:6px 0}
  .high{border-color:#4caf50}.medium{border-color:#ffa000}
  .meta{color:#666;font-size:12px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .stats {border:1px solid #ddd;border-radius:8px;padding:10px 12px;margin:12px 0;background:#fafafa;display:flex;gap:16px;flex-wrap:wrap}
  .stats b {font-weight:600}
  .stats .pill{padding:2px 8px;border-radius:999px;border:1px solid #ccc;background:#fff}
  .race.has-filter .pick.filtered{
    outline:2px solid #4caf50;
    border-left-color:#4caf50;
    background:#f4fff5;
  }
  .race.has-filter .pick.dim{ opacity:.35 }
  .pick.excluded { opacity:.45; filter:grayscale(0.2) }
  .pick .chk { margin-right:6px; vertical-align:middle }
  @media(max-width:720px){.grid{grid-template-columns:1fr}}
</style>

<header>
  <h1 style="margin-right:auto;">Daily Horse Racing Picks</h1>
  <label>Month:
    <select id="month"></select>
  </label>
  <label>Day:
    <select id="day"></select>
  </label>
  <button id="load">Load</button>
  <button id="latest">Latest</button>
  <button id="all">All</button>
  <button id="none">None</button>
  <label>Stake (€):
  <input id="stake" type="number" step="0.01" min="0" value="1" style="width:6ch">
  </label>
  <label>Min odds:
  <input id="minOdds" type="number" step="0.01" min="1" placeholder="e.g. 1.5" style="width:7ch">
  </label>
  <label>Max odds:
    <input id="maxOdds" type="number" step="0.01" min="1" placeholder="e.g. 6.0" style="width:7ch">
  </label>
  <button id="apply">Apply</button>
</header>

<p class="meta" id="stamp"></p>
<div id="root">Loading…</div>

<script>
const monthSel = document.getElementById('month');
const daySel = document.getElementById('day');
const stamp = document.getElementById('stamp');
const root = document.getElementById('root');

// ---- FILTER STATE ----
let currentDayData = null;
let currentResults = null;

const minOddsEl = document.getElementById('minOdds');
const maxOddsEl = document.getElementById('maxOdds');
const stakeEl   = document.getElementById('stake');

// set of pick keys you WANT included (default = all)
const selectedPicks = new Set();

// stable key: Course||Time||Pick Name (normalized)
const keyForPick = (course,time,name) =>
  `${(course||'').trim()}||${(time||'').trim()}||${(name||'').toLowerCase().replace(/\s+/g,' ').trim()}`;

async function fetchJSON(url){
  const res = await fetch(url, {cache:'no-store'});
  if(!res.ok) throw new Error(`GET ${url} -> ${res.status}`);
  return res.json();
}
// === stats helpers ===
function toDec(x){
  if (x == null) return null;
  if (typeof x === 'number' && isFinite(x)) return x;
  if (typeof x === 'string'){
    const s = x.trim();

    // plain decimal: "3.85"
    if (/^\d+(\.\d+)?$/.test(s)) return parseFloat(s);

    // fractional like "9/4" -> 3.25
    const m = s.match(/^(\d+)\s*\/\s*(\d+)$/);
    if (m) { const a=+m[1], b=+m[2]; if (b) return a/b + 1; }

    // pull first number from a note like "EXC 3.85" or "SBK 5/2"
    const num = s.match(/(\d+(?:\.\d+)?)(?:\s*\/\s*(\d+))?/);
    if (num){
      if (num[2]) { const a=+num[1], b=+num[2]; if (b) return a/b + 1; }
      return parseFloat(num[1]);
    }
  }
  return null;
}

function pickDecimalOdds(p){
  return (
    toDec(p.exc_dec) ??
    toDec(p.exchange) ??
    toDec(p.odds) ??
    toDec(p.odds_note) ??
    null
  );
}

function normName(s){ return (s||'').toLowerCase().replace(/\s+/g,' ').trim(); }

function summarize(dayData, resultsJson){
  const resByKey = new Map(resultsJson.results.map(r => [`${r.course.trim()}||${r.time.trim()}`, r]));
  let hits=0, misses=0, racesWithResult=0;

  let bets=0, wins=0, pnl=0, staked=0;

  for (const r of (dayData.races||[])){
    const key = `${(r.course||'').trim()}||${(r.time||'').trim()}`;
    const res = resByKey.get(key);
    if (res && res.winner) {
      racesWithResult++;
      const wName = normName(res.winner.name);
      const short = r.shortlist || [];

      // race hit/miss
      const raceHit = short.some(p => normName(p.name) === wName);
      if (raceHit) hits++; else misses++;

      // per-pick betting P/L (1€ each) if odds exist
      for (const p of short){
        const dec = pickDecimalOdds(p);
        if (dec){
          bets++;
          staked += 1;
          const isWin = normName(p.name) === wName;
          if (isWin){
            wins++;
            pnl += (dec - 1); // net profit on 1€ stake
          } else {
            pnl -= 1;
          }
        }
      }
    }
  }

  const roi = staked ? (pnl / staked) : 0;
  return { hits, misses, racesWithResult, bets, wins, staked, pnl, roi };
}

function renderStatsHeader(stats){
  // remove old
  document.getElementById('statsbar')?.remove();

  const d = document.createElement('div');
  d.id = 'statsbar';
  d.className = 'stats';
  d.innerHTML = `
    <div><b>Results coverage:</b> ${stats.racesWithResult}</div>
    <div class="pill"><b>Hits:</b> ${stats.hits}</div>
    <div class="pill"><b>Misses:</b> ${stats.misses}</div>
    <div class="pill"><b>Bets:</b> ${stats.bets}</div>
    <div class="pill"><b>Wins:</b> ${stats.wins}</div>
    <div class="pill"><b>P/L:</b> €${stats.pnl.toFixed(2)}</div>
    <div class="pill"><b>ROI:</b> ${(stats.roi*100).toFixed(1)}%</div>
  `;
  // stick it under the header controls, above #stamp
  const header = document.querySelector('header');
  header.insertAdjacentElement('afterend', d);
}

function render(data){
  // store a clean base header once (see step 2)
  baseStampText = `Model: ${data.model || 'n/a'} • Generated: ${new Date(data.generated_at || Date.now()).toLocaleString()}`;
  stamp.textContent = baseStampText;

  root.innerHTML = '';
  for (const r of (data.races || [])) {
    const div = document.createElement('div'); div.className = 'race';
    div.innerHTML = `<h2>${r.course} — ${r.time}</h2>
      <div class="meta"><a href="${r.url}" target="_blank" rel="noopener">Racecard</a></div>`;

    if (!r.shortlist?.length) {
      div.innerHTML += `<p>No shortlisted picks.</p>`;
    } else {
      for (const p of r.shortlist) {
        const conf = (p.confidence||'').toLowerCase();
        const pk = keyForPick(r.course, r.time, p.name);

        // default-select on first render
        selectedPicks.add(pk);

        const dec = pickDecimalOdds(p);
        const decNote = dec ? ` • Dec: ${dec.toFixed(2)}` : '';

        div.innerHTML += `
          <div class="pick ${conf.includes('high')?'high':conf.includes('medium')?'medium':''}"
              data-pickkey="${pk}">
            <input class="chk" type="checkbox" checked aria-label="Include pick" />
            <strong>${p.name}</strong> — ${p.rationale || ''}<br/>
            <span class="meta">
              ${p.jockey?`J: ${p.jockey} • `:''}${p.trainer?`T: ${p.trainer} • `:''}${p.form?`F: ${p.form} • `:''}${p.odds_note||''}${decNote}
            </span>
          </div>`;
      }
    }
    root.appendChild(div);
  }
}

function applyHighlight(minDec, maxDec){
  // toggle styles per pick
  for (const raceEl of document.querySelectorAll('.race')){
    let anyFiltered = false;
    for (const pickEl of raceEl.querySelectorAll('.pick')){
      const dec = parseFloat(pickEl.getAttribute('data-dec'));
      const ok = Number.isFinite(dec)
        && (minDec==null || dec>=minDec)
        && (maxDec==null || dec<=maxDec);

      pickEl.classList.remove('filtered','dim');
      if (minDec==null && maxDec==null) continue; // no filter — leave clean

      if (ok){ pickEl.classList.add('filtered'); anyFiltered = true; }
      else   { pickEl.classList.add('dim'); }
    }
    raceEl.classList.toggle('has-filter', (minDec!=null || maxDec!=null) && anyFiltered);
  }
}

async function tryFetchResultsFor(dateStr) {
  const [Y,M] = dateStr.split('-');
  const url = `./results/${Y}/${M}/${dateStr}.json`;
  const res = await fetch(url, {cache:'no-store'});
  if (!res.ok) return null;
  return res.json();
}

function updatePerRaceFilterBadges(minDec, maxDec) {
  if (!currentDayData || !currentResults) return;

  const resByKey = new Map(
    (currentResults.results || []).map(r => [`${(r.course||'').trim()}||${(r.time||'').trim()}`, r])
  );

  document.querySelectorAll('.race').forEach(raceEl => {
    // clean existing filtered badge
    raceEl.querySelector('.filter-badge')?.remove();

    const h2 = raceEl.querySelector('h2');
    if (!h2) return;
    const [course, time] = h2.textContent.split(' — ').map(s => s.trim());
    const res = resByKey.get(`${course}||${time}`);
    if (!res || !res.winner) return;

    const wName = normName(res.winner.name);
    const raceObj = (currentDayData.races || []).find(rr =>
      (rr.course||'').trim() === course && (rr.time||'').trim() === time
    );
    const picks = (raceObj?.shortlist || []);

    // Apply odds range
    const filtered = picks.filter(p => {
      const dec = pickDecimalOdds(p);
      return dec && withinRange(dec, minDec, maxDec);
    });

    // If no filter set and no filtered picks, show nothing
    const filterActive = (minDec != null || maxDec != null);
    if (!filterActive) return;

    const badge = document.createElement('div');
    badge.className = 'meta filter-badge';

    if (!filtered.length) {
      badge.textContent = 'Filtered: no picks in range';
    } else {
      const isHit = filtered.some(p => normName(p.name) === wName);
      badge.textContent = `Filtered: ${isHit ? '✅ HIT' : '❌ MISS'} (considered ${filtered.length} pick${filtered.length>1?'s':''})`;
    }
    raceEl.appendChild(badge);
  });
}

function setBaseStamp(dayData){
  const base = `Model: ${dayData.model || 'n/a'} • Generated: ${new Date(dayData.generated_at || Date.now()).toLocaleString()}`;
  stamp.dataset.base = base;
  stamp.textContent = base;
}

// After you load a day file, call:
async function renderWithResults(dayData) {
  setBaseStamp(dayData);
  render(dayData);

function applyHighlightFromInputs(){
  const minVal = parseFloat(minOddsEl.value);
  const maxVal = parseFloat(maxOddsEl.value);
  const minDec = Number.isFinite(minVal) ? minVal : null;
  const maxDec = Number.isFinite(maxVal) ? maxVal : null;

  document.querySelectorAll('.pick').forEach(div => {
    const pk = div.dataset.pickkey;
    const name = div.querySelector('strong')?.textContent || '';
    // find underlying pick data (optional; you can also embed Dec in a data-attr when rendering)
    // quick parse from text you already show:
    const decText = div.querySelector('.meta')?.textContent || '';
    const dec = parseDecimalFromText(decText);

    const selected = selectedPicks.has(pk);
    const inRange = (dec && withinRange(dec, minDec, maxDec));

    // add/remove a class to highlight
    if (selected && inRange) {
      div.classList.add('in-range');
    } else {
      div.classList.remove('in-range');
    }
  });
}

  function attachPickCheckboxHandlers() {
    document.querySelectorAll('.pick .chk').forEach(chk => {
      chk.addEventListener('change', () => {
        const pickDiv = chk.closest('.pick');
        const pk = pickDiv?.dataset.pickkey;
        if (!pk) return;

        if (chk.checked) {
          selectedPicks.add(pk);
          pickDiv.classList.remove('excluded');
        } else {
          selectedPicks.delete(pk);
          pickDiv.classList.add('excluded');
        }

        // Recompute header with current filters + stake
        recalcHeaderFromInputs();
        // Re-apply highlights so only included picks show as highlighted
        applyHighlightFromInputs();
      });
    });
  }  
  const d = (dayData.date)
    || (dayData.generated_at ? new Date(dayData.generated_at).toISOString().slice(0,10) : null);
  if (!d) return;

  const results = await tryFetchResultsFor(d);
  if (!results) return;

  // annotate DOM with winners (unchanged)
  const byKey = new Map(results.results.map(r => [`${r.course.trim()}||${r.time.trim()}`, r]));
  for (const el of document.querySelectorAll('.race')) {
    const h2 = el.querySelector('h2');
    if (!h2) continue;
    const [course, time] = h2.textContent.split(' — ').map(s => s.trim());
    const k = `${course}||${time}`;
    const r = byKey.get(k);
    if (!r) continue;

    const badge = document.createElement('div');
    badge.className = 'meta';
    if (r.winner) {
      badge.textContent = `Result: ${r.winner.name}${r.winner.sp ? ` (SP ${r.winner.sp})` : ''} • ${r.hit ? '✅ HIT' : '❌ MISS'} (all picks)`;
    } else {
      badge.textContent = 'Result: not available';
    }
    const anchorMeta = el.querySelector('.meta');
    if (anchorMeta && anchorMeta.nextSibling) {
      anchorMeta.parentNode.insertBefore(badge, anchorMeta.nextSibling);
    } else {
      el.appendChild(badge);
    }
  }

  // NEW — keep globals so the filter can recalc without reloading
  currentDayData = dayData;        // <—— save day
  currentResults = results;        // <—— save results

  // Initial header stats (no odds filter yet or using current inputs if present)
const minVal = parseFloat(minOddsEl.value);
const maxVal = parseFloat(maxOddsEl.value);
const minDec = Number.isFinite(minVal) ? minVal : null;
const maxDec = Number.isFinite(maxVal) ? maxVal : null;

const stake = getStake();
const stats = computeHeaderStats(currentDayData, currentResults, minDec, maxDec, stake);
renderHeader(stats, minDec, maxDec, stake);
applyHighlight(minDec, maxDec); // <- NEW: initial highlight
updatePerRaceFilterBadges(minDec, maxDec);

}

async function loadLatest(){
  const data = await fetchJSON('./latest.json');
  await renderWithResults(data);
}

async function loadDay(path){
  const data = await fetchJSON('./' + path);
  await renderWithResults(data);
}

function populate(index){
  // months sorted descending
  const months = Object.keys(index.months || {}).sort().reverse();
  monthSel.innerHTML = months.map(m => `<option value="${m}">${m}</option>`).join('');
  if (months.length) {
    const first = months[0];
    daySel.innerHTML = index.months[first].slice().reverse()
      .map(d => `<option value="${d.path}">${d.date}</option>`).join('');
  }
}

monthSel.addEventListener('change', async () => {
  const idx = await fetchJSON('./picks/index.json');
  const key = monthSel.value;
  const days = (idx.months && idx.months[key]) ? idx.months[key].slice().reverse() : [];
  daySel.innerHTML = days.map(d => `<option value="${d.path}">${d.date}</option>`).join('');
});

document.getElementById('all').addEventListener('click', () => {
  document.querySelectorAll('.pick').forEach(div => {
    const pk = div.dataset.pickkey;
    if (!pk) return;
    selectedPicks.add(pk);
    div.classList.remove('excluded');
    const chk = div.querySelector('.chk');
    if (chk) chk.checked = true;
  });
  recalcHeaderFromInputs();
  applyHighlightFromInputs();
});

document.getElementById('none').addEventListener('click', () => {
  document.querySelectorAll('.pick').forEach(div => {
    const pk = div.dataset.pickkey;
    if (!pk) return;
    selectedPicks.delete(pk);
    div.classList.add('excluded');
    const chk = div.querySelector('.chk');
    if (chk) chk.checked = false;
  });
  recalcHeaderFromInputs();
  applyHighlightFromInputs();
});

document.getElementById('load').addEventListener('click', async () => {
  const p = daySel.value;
  if (p) loadDay(p);
});

document.getElementById('latest').addEventListener('click', loadLatest);

(async () => {
  try {
    const idx = await fetchJSON('./picks/index.json');
    populate(idx);
    await loadLatest();
  } catch (e) {
    console.error(e);
    root.textContent = 'No data yet.';
  }
})();

// Robust odds parser: decimal like "2.48", or fractional like "5/2"
function parseDecimalFromText(s) {
  if (!s) return null;
  s = String(s);

  // Try explicit "exchange" or "decimal" first (common in your JSON)
  const ex = s.match(/(?:exchange|decimal)\s*[:=]?\s*([0-9]+(?:\.[0-9]+)?)/i);
  if (ex) {
    const v = parseFloat(ex[1]);
    if (v >= 1) return v;
  }

  // Any standalone decimal >= 1.0
  const dec = s.match(/(^|\s)([1-9]\d*(?:\.\d+)?)(?=\s|$|,)/);
  if (dec) {
    const v = parseFloat(dec[2]);
    if (v >= 1) return v;
  }

  // Fraction like "5/2" → 3.5
  const frac = s.match(/([0-9]+)\s*\/\s*([0-9]+)/);
  if (frac) {
    const a = parseFloat(frac[1]), b = parseFloat(frac[2] || '1');
    if (b > 0) return (a / b) + 1;
  }

  return null;
}

// Pull a decimal from a pick object (checks multiple fields)
function pickDecimalOdds(pick) {
  // common fields you’ve used: odds_note, odds, sbk, exchange, etc.
  if (pick.decimal) {
    const v = Number(pick.decimal);
    if (!Number.isNaN(v) && v >= 1) return v;
  }
  if (pick.exchange) {
    const v = Number(pick.exchange);
    if (!Number.isNaN(v) && v >= 1) return v;
  }
  if (pick.sbk) {
    const parsed = parseDecimalFromText(String(pick.sbk));
    if (parsed) return parsed;
  }
  if (pick.odds) {
    // odds may be an object or string
    if (typeof pick.odds === 'string') {
      const parsed = parseDecimalFromText(pick.odds);
      if (parsed) return parsed;
    } else {
      // try odds.decimal or odds.exchange
      const cand = pick.odds.decimal ?? pick.odds.exchange;
      const v = Number(cand);
      if (!Number.isNaN(v) && v >= 1) return v;
      const str = [pick.odds.sbk, pick.odds.frac, pick.odds.text].filter(Boolean).join(' ');
      const parsed = parseDecimalFromText(str);
      if (parsed) return parsed;
    }
  }
  if (pick.odds_note) {
    const parsed = parseDecimalFromText(pick.odds_note);
    if (parsed) return parsed;
  }
  // As a last resort, scan concatenated textual fields
  const bag = [pick.rationale, pick.note, pick.text].filter(Boolean).join(' ');
  if (bag) {
    const parsed = parseDecimalFromText(bag);
    if (parsed) return parsed;
  }
  return null;
}

function normName(s){ return (s||'').toLowerCase().replace(/\s+/g,' ').trim(); }

function withinRange(dec, min, max) {
  if (min != null && dec < min) return false;
  if (max != null && dec > max) return false;
  return true;
}

// Compute header stats with optional odds range
function computeHeaderStats(dayData, resultsJson, minDec, maxDec, stake, selected) {
  if (!dayData || !resultsJson) return {hits:0, misses:0, staked:0, pnl:0, picks:0};
  const resByKey = new Map((resultsJson.results || []).map(r => [`${(r.course||'').trim()}||${(r.time||'').trim()}`, r]));

  let hits=0, misses=0, staked=0, pnl=0, picks=0;

  for (const race of (dayData.races || [])) {
    const key = `${(race.course||'').trim()}||${(race.time||'').trim()}`;
    const res = resByKey.get(key);
    if (!res || !res.winner) continue;

    const wName = normName(res.winner.name);
    const filtered = (race.shortlist || []).filter(p => {
      const pk = keyForPick(race.course, race.time, p.name);
      if (!selected.has(pk)) return false;                 // manual filter
      const dec = pickDecimalOdds(p);
      return dec && withinRange(dec, minDec, maxDec);      // odds range
    });

    if (!filtered.length) continue;

    const raceHit = filtered.some(p => normName(p.name) === wName);
    if (raceHit) hits++; else misses++;

    for (const p of filtered) {
      const dec = pickDecimalOdds(p);
      if (!dec) continue;
      picks++;
      staked += stake;
      pnl += (normName(p.name) === wName) ? (dec - 1) * stake : -1 * stake;
    }
  }
  return {hits, misses, staked, pnl, picks};
}


function getStake() {
  const v = stakeEl ? parseFloat(stakeEl.value) : NaN;
  return Number.isFinite(v) && v > 0 ? v : 1;
}

function recalcHeaderFromInputs(){
  if (!currentDayData || !currentResults) return;
  const minVal = parseFloat(minOddsEl.value);
  const maxVal = parseFloat(maxOddsEl.value);
  const minDec = Number.isFinite(minVal) ? minVal : null;
  const maxDec = Number.isFinite(maxVal) ? maxVal : null;
  const stake = getStake();

  const stats = computeHeaderStats(currentDayData, currentResults, minDec, maxDec, stake, selectedPicks);
  renderHeader(stats, minDec, maxDec, stake);
}

document.getElementById('apply').addEventListener('click', recalcHeaderFromInputs);

// (nice-to-have) Recalculate on Enter in either box
[minOddsEl, maxOddsEl].forEach(el => {
  el.addEventListener('keydown', e => { if (e.key === 'Enter') recalcHeaderFromInputs(); });
});

// (optional) live update while typing
[minOddsEl, maxOddsEl].forEach(el => {
  el.addEventListener('input', () => {
    // only recompute if both are blank or valid numbers
    const v = el.value.trim();
    if (v === '' || !Number.isNaN(parseFloat(v))) recalcHeaderFromInputs();
  });
});
stakeEl.addEventListener('change', recalcHeaderFromInputs); // optional live update

// Render header line
function renderHeader(stats, minDec, maxDec, stake) {
  const base = stamp.dataset.base || stamp.textContent.replace(/\s•\sHits\/Misses.*$/, '');

  const filt =
    (minDec != null || maxDec != null)
      ? ` • Filter: ${minDec!=null?`≥${minDec}`:''}${(minDec!=null && maxDec!=null)?' & ':''}${maxDec!=null?`≤${maxDec}`:''}`
      : '';

  const plStr = (stats.pnl >= 0 ? '+' : '') + stats.pnl.toFixed(2);

  stamp.textContent =
    `${base} • Hits/Misses: ${stats.hits}/${stats.misses}` +
    ` • P/L (€${stake} stakes): ${plStr} over ${stats.picks} picks` +
    `${filt}`;
}

</script>
</html>
